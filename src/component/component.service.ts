import {
  Injectable,
  ForbiddenException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { CreateComponentDto } from './dto/create-component.dto';
import { UpdateComponentDto } from './dto/update-component.dto';

// Define the Component type manually if not generated by Prisma
type Component = {
  id: number;
  name: string;
  type: string;
  config: Record<string, any>; // Ensure config is always treated as Record<string, any>
  pageId: number;
  createdAt: Date;
  updatedAt: Date;
};

@Injectable()
export class ComponentService {
  constructor(private readonly prisma: PrismaService) {}

  private async verifyOwnershipByPage(pageId: number, userId: number) {
    const page = await this.prisma.page.findUnique({
      where: { id: pageId },
      include: { project: true },
    });

    if (!page) throw new NotFoundException('Page not found');

    console.log('Page Owner ID:', page.project.ownerId);
    console.log('User ID:', userId);

    if (page.project.ownerId !== userId)
      throw new ForbiddenException('Access denied');
    return page;
  }

  async create(userId: number, dto: CreateComponentDto): Promise<Component> {
    await this.verifyOwnershipByPage(dto.pageId, userId);
    const createdComponent = await this.prisma.component.create({
      data: {
        name: dto.name,
        type: dto.type,
        config: dto.config ?? {}, // Ensure config is non-nullable
        pageId: dto.pageId,
      },
    });

    return {
      ...createdComponent,
      config: createdComponent.config as Record<string, any>, // Explicitly cast config
    };
  }

  async findByPage(pageId: number, userId: number): Promise<Component[]> {
    await this.verifyOwnershipByPage(pageId, userId);
    const components = await this.prisma.component.findMany({
      where: { pageId },
      orderBy: { createdAt: 'desc' },
    });

    return components.map((component) => ({
      ...component,
      config: (component.config as Record<string, any>) ?? {}, // Explicitly cast config
    }));
  }

  async findOne(id: number, userId: number): Promise<Component> {
    const component = await this.prisma.component.findUnique({
      where: { id },
      include: { page: { include: { project: true } } },
    });

    if (!component) throw new NotFoundException('Component not found');
    if (component.page.project.ownerId !== userId)
      throw new ForbiddenException('Access denied');

    return {
      ...component,
      config: (component.config as Record<string, any>) ?? {}, // Ensure config is non-nullable
    };
  }

  async update(
    id: number,
    userId: number,
    dto: UpdateComponentDto,
  ): Promise<Component> {
    const component = await this.findOne(id, userId);
    const updatedComponent = await this.prisma.component.update({
      where: { id: component.id },
      data: {
        name: dto.name ?? component.name,
        type: dto.type ?? component.type,
        config: dto.config ?? component.config,
        updatedAt: new Date(),
      },
    });

    return {
      ...updatedComponent,
      config: (updatedComponent.config as Record<string, any>) ?? {}, // Ensure config is non-nullable
    };
  }

  async remove(id: number, userId: number): Promise<Component> {
    await this.findOne(id, userId);
    const deletedComponent = await this.prisma.component.delete({
      where: { id },
    });
    return {
      ...deletedComponent,
      config: (deletedComponent.config as Record<string, any>) ?? {}, // Ensure config is non-nullable
    };
  }
}
